<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Privater Vokabeltrainer</title>
  <style>
    :root {
      --bg: #0f1419;
      --card: #141a21;
      --fg: #e6edf3;
      --muted: #9aa7b3;
      --accent: #4aa3ff;
      --accent-2: #22c55e;
      --warn: #ef4444;
      --border: #243041;
      --focus: #7cc4ff;
    }
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      background: var(--bg);
      color: var(--fg);
      font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }
    .container {
      max-width: 800px;
      margin: 0 auto;
      padding: 16px;
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    }
    header {
      display: flex; align-items: center; justify-content: space-between; gap: 12px;
      margin: 12px 0 20px;
    }
    header h1 {
      font-size: 20px; margin: 0; font-weight: 600;
    }
    .row {
      display: grid; gap: 12px;
    }
    @media (min-width: 640px) {
      .row.cols-2 { grid-template-columns: 1fr 1fr; }
      .row.cols-3 { grid-template-columns: repeat(3, 1fr); }
    }
    .btn {
      display: inline-flex; align-items: center; justify-content: center;
      gap: 8px; padding: 12px 14px; border-radius: 10px;
      border: 1px solid var(--border); background: #18202a; color: var(--fg);
      font-weight: 600; cursor: pointer; touch-action: manipulation;
    }
    .btn:hover { background: #1a2430; }
    .btn:active { transform: translateY(0.5px); }
    .btn.primary { background: var(--accent); color: #061423; border-color: transparent; }
    .btn.primary:hover { filter: brightness(1.05); }
    .btn.success { background: var(--accent-2); color: #062612; border-color: transparent; }
    .btn.warn { background: #ef4444; color: #2b0b0b; border-color: transparent; }
    .btn.ghost { background: transparent; }
    .btn.small { padding: 8px 10px; font-weight: 600; }
    .toolbar { display: flex; flex-wrap: wrap; gap: 8px; }
    .input {
      width: 100%; padding: 12px 14px; border-radius: 10px; border: 1px solid var(--border);
      background: #11161d; color: var(--fg); font-size: 18px;
    }
    .input:focus {
      outline: 2px solid var(--focus);
      outline-offset: 2px;
    }
    .badge {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 6px 10px; border-radius: 999px; background: #17212b; border: 1px solid var(--border);
      color: var(--muted); font-weight: 600; font-size: 13px;
    }
    .section-list { display: grid; gap: 10px; }
    .section-item {
      display: flex; align-items: center; justify-content: space-between;
      padding: 12px; border-radius: 10px; border: 1px solid var(--border); background: #121922;
      cursor: pointer;
    }
    .section-item:hover { background: #15202b; }
    .label { color: var(--muted); font-size: 13px; }
    .hint { color: var(--muted); font-size: 14px; }
    .status { display: flex; gap: 8px; flex-wrap: wrap; }
    .spacer { height: 10px; }
    .divider { height: 1px; background: var(--border); margin: 10px 0; }
    .center { text-align: center; }
    .hidden { display: none !important; }
    .error {
      background: #2a1212; border: 1px solid #742b2b; color: #ffb4b4;
      padding: 12px; border-radius: 10px; margin: 8px 0;
    }

    /* Modal */
    dialog {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 0;
      color: var(--fg);
      background: var(--card);
      width: min(720px, 90vw);
    }
    dialog::backdrop {
      background: rgba(0,0,0,0.6);
    }
    .modal-header {
      padding: 14px 16px; border-bottom: 1px solid var(--border);
      display: flex; align-items: center; justify-content: space-between;
    }
    .modal-body { padding: 14px 16px; }
    .modal-footer { padding: 14px 16px; border-top: 1px solid var(--border); display: flex; justify-content: flex-end; }

    /* Auth screen */
    .lock {
      min-height: 92vh; display: grid; place-items: center; padding: 16px;
    }
    .lock .card { width: min(420px, 92vw); }
  </style>
</head>
<body>
  <div id="auth" class="lock">
    <div class="card">
      <h2 style="margin:0 0 12px;">Zugang gesichert</h2>
      <p class="hint">Bitte Passwort eingeben, um den privaten Vokabeltrainer zu öffnen.</p>
      <div class="spacer"></div>
      <input id="pwd" class="input" type="password" placeholder="Passwort" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" />
      <div class="spacer"></div>
      <div class="toolbar">
        <button id="btnEnter" class="btn primary" type="button">Einloggen</button>
        <button id="btnHelpAuth" class="btn ghost" type="button">Hilfe</button>
      </div>
      <div id="authError" class="error hidden">Falsches Passwort. Zugriff verweigert.</div>
    </div>
  </div>

  <div id="app" class="container hidden" aria-live="polite">
    <header>
      <h1>Privater Vokabeltrainer</h1>
      <div class="toolbar">
        <button id="btnHelp" class="btn ghost small" type="button">Hilfe</button>
        <button id="btnExport" class="btn small" type="button">Export Data</button>
        <label class="btn small" for="importProgress">Import Data</label>
        <input id="importProgress" type="file" accept="application/json" class="hidden" />
      </div>
    </header>

    <div id="globalError" class="error hidden"></div>

    <div class="card" id="loaderCard">
      <h3 style="margin-top:0;">Vokabeln laden</h3>
      <p class="hint">Lade automatisch <code>vocabulary.json</code> aus demselben Ordner. Alternativ kannst du eine eigene Datei importieren.</p>
      <div class="toolbar">
        <label class="btn" for="importVocab">Eigene Vokabeln importieren</label>
        <input id="importVocab" type="file" accept="application/json" class="hidden" />
        <button id="btnReloadVocab" class="btn ghost" type="button">Erneut versuchen</button>
      </div>
      <div id="loadStatus" class="hint">Status: wartet auf Laden…</div>
    </div>

    <div id="sectionsCard" class="card hidden">
      <h3 style="margin-top:0;">Abschnitte</h3>
      <p class="hint">Wähle eine Section. Eine Section ist erledigt, wenn keine Vokabeln mehr offen sind.</p>
      <div id="sections" class="section-list"></div>
    </div>

    <div id="trainerCard" class="card hidden">
      <div class="row">
        <div>
          <div class="status">
            <span class="badge"><strong>Section:</strong> <span id="statusSection">–</span></span>
            <span class="badge"><strong>Offen:</strong> <span id="statusOpen">0</span></span>
            <span class="badge"><strong>Richtig:</strong> <span id="statusRight">0</span></span>
            <span class="badge"><strong>Falsch:</strong> <span id="statusWrong">0</span></span>
          </div>
        </div>
        <div class="toolbar" style="justify-content:flex-end;">
          <button id="btnBackToSections" class="btn ghost small" type="button">Abschnitte</button>
        </div>
      </div>

      <div class="divider"></div>

      <div id="qa">
        <div class="label">Deutsch</div>
        <div id="question" style="font-size:22px; font-weight:700; margin:4px 0 12px;">–</div>

        <div class="label">Antwort auf Englisch</div>
        <input id="answer" class="input" type="text"
               placeholder="Englische Übersetzung"
               autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"
               inputmode="latin"
               />

        <div id="feedback" class="hidden" style="margin-top:12px;">
          <div class="badge"><strong>Lösung:</strong> <span id="solution">–</span></div>
          <div class="spacer"></div>
          <div><strong>Beispielsatz:</strong> <span id="example">–</span></div>
        </div>

        <div class="spacer"></div>

        <div class="toolbar">
          <button id="btnCheck" class="btn primary" type="button">Überprüfen</button>
          <button id="btnSkip" class="btn" type="button">Überspringen</button>
        </div>

        <div id="qaError" class="error hidden"></div>
      </div>
    </div>
  </div>

  <!-- Hilfe-Modal -->
  <dialog id="helpModal" aria-label="Hilfe und Anleitung">
    <div class="modal-header">
      <h3 style="margin:0;">Hilfe & Anleitung</h3>
      <button id="btnCloseHelpTop" class="btn ghost small" type="button">Schließen</button>
    </div>
    <div class="modal-body">
      <div class="row">
        <div class="card" style="background:#10161d;">
          <h4 style="margin-top:0;">Zugang & Sicherheit</h4>
          <ul>
            <li><strong>Passwort:</strong> Der Zugang ist geschützt. Hartkodiertes Passwort: "AbCd-1234".</li>
          </ul>
        </div>
        <div class="card" style="background:#10161d;">
          <h4 style="margin-top:0;">Vokabeln laden</h4>
          <ul>
            <li><strong>Auto-Load:</strong> Beim Öffnen wird automatisch <code>vocabulary.json</code> aus demselben Ordner geladen.</li>
            <li><strong>Eigene Datei:</strong> Über „Eigene Vokabeln importieren“ kannst du kompatible JSON-Dateien laden. Sie werden nicht gespeichert und müssen nach jedem Öffnen erneut importiert werden.</li>
            <li><strong>Format-Beispiel:</strong> 
              <pre style="white-space:pre-wrap; background:#0d131a; border:1px solid #1e2a39; border-radius:8px; padding:10px;">[
  {"de":"Apfel","en":"apple","section":"Obst","example":"Ich esse einen ___."},
  {"de":"laufen","en":"to run","section":"Verben","example":"Ich ___ schnell."}
]</pre>
            </li>
          </ul>
        </div>
        <div class="card" style="background:#10161d;">
          <h4 style="margin-top:0;">Abfrage-Logik</h4>
          <ul>
            <li><strong>Richtung:</strong> Deutsch → Eingabe Englisch.</li>
            <li><strong>Prüfung:</strong> Case-sensitive. Exakt passende Antwort ist „richtig“, sonst „falsch“.</li>
            <li><strong>Queue:</strong> Zufällige Auswahl. Bei falscher Antwort wird die Vokabel nach hinten verschoben und kurzfristig seltener abgefragt.</li>
            <li><strong>Feedback:</strong> Nach „falsch“ oder „überspringen“ siehst du Lösung und Beispielsatz. Eingabefeld ist deaktiviert, „Überprüfen“ wird zu „Weiter!“, „Überspringen“ verschwindet.</li>
            <li><strong>Section-Ende:</strong> Eine Section ist erledigt, wenn keine Vokabeln mehr offen sind.</li>
          </ul>
        </div>
        <div class="card" style="background:#10161d;">
          <h4 style="margin-top:0;">Speicherung & Synchronisation</h4>
          <ul>
            <li><strong>Auto-Save:</strong> Fortschritt wird lokal im Browser (localStorage) gespeichert.</li>
            <li><strong>Export:</strong> „Export Data“ lädt <code>progress.json</code> herunter.</li>
            <li><strong>Import:</strong> „Import Data“ lädt eine <code>progress.json</code> hoch und merged/überschreibt den lokalen Fortschritt.</li>
            <li><strong>Mehrgeräte:</strong> Nur manuell über <code>progress.json</code>. Keine Cloud-Sync.</li>
          </ul>
        </div>
        <div class="card" style="background:#10161d;">
          <h4 style="margin-top:0;">Mobile & Accessibility</h4>
          <ul>
            <li><strong>Fokus:</strong> Das Eingabefeld erhält Fokus beim Laden. Enter bestätigt.</li>
            <li><strong>Keyboard:</strong> Autokorrektur, Autokapitalisierung, Vorschläge sind deaktiviert.</li>
          </ul>
        </div>
        <div class="card" style="background:#10161d;">
          <h4 style="margin-top:0;">Fehlermeldungen</h4>
          <ul>
            <li><strong>Warnungen:</strong> Fehler beim Laden, ungültige Dateien, leere Sections usw. werden klar angezeigt.</li>
          </ul>
        </div>
      </div>
    </div>
    <div class="modal-footer">
      <button id="btnCloseHelp" class="btn primary" type="button">Alles klar</button>
    </div>
  </dialog>

  <script>
    // --- Zugang / Sicherheit ---
    const HARDCODED_PASSWORD = "AbCd-1234";
    const elAuth = document.getElementById('auth');
    const elPwd = document.getElementById('pwd');
    const elBtnEnter = document.getElementById('btnEnter');
    const elAuthError = document.getElementById('authError');
    const elBtnHelpAuth = document.getElementById('btnHelpAuth');

    const elApp = document.getElementById('app');

    const helpModal = document.getElementById('helpModal');
    const btnHelp = document.getElementById('btnHelp');
    const btnCloseHelp = document.getElementById('btnCloseHelp');
    const btnCloseHelpTop = document.getElementById('btnCloseHelpTop');

    const elLoaderCard = document.getElementById('loaderCard');
    const elLoadStatus = document.getElementById('loadStatus');
    const elImportVocab = document.getElementById('importVocab');
    const elBtnReloadVocab = document.getElementById('btnReloadVocab');

    const elSectionsCard = document.getElementById('sectionsCard');
    const elSections = document.getElementById('sections');

    const elTrainerCard = document.getElementById('trainerCard');
    const elQuestion = document.getElementById('question');
    const elAnswer = document.getElementById('answer');
    const elFeedback = document.getElementById('feedback');
    const elSolution = document.getElementById('solution');
    const elExample = document.getElementById('example');
    const elBtnCheck = document.getElementById('btnCheck');
    const elBtnSkip = document.getElementById('btnSkip');
    const elQaError = document.getElementById('qaError');

    const elStatusSection = document.getElementById('statusSection');
    const elStatusOpen = document.getElementById('statusOpen');
    const elStatusRight = document.getElementById('statusRight');
    const elStatusWrong = document.getElementById('statusWrong');
    const elBtnBackToSections = document.getElementById('btnBackToSections');

    const elGlobalError = document.getElementById('globalError');

    const elBtnExport = document.getElementById('btnExport');
    const elImportProgress = document.getElementById('importProgress');

    // LocalStorage keys
    const LS_KEY_PROGRESS = 'vt_progress_v1';
    const LS_KEY_META = 'vt_meta_v1';

    // State
    let vocabularyData = []; // loaded or imported vocabulary items
    let sections = []; // names
    let queues = {}; // sectionName -> array of items with cooldown
    let currentSection = null;
    let currentItem = null;
    let showingFeedback = false;

    let sessionStats = { right: 0, wrong: 0 };

    function setError(el, msg) {
      if (!msg) { el.classList.add('hidden'); el.textContent=''; return; }
      el.textContent = msg;
      el.classList.remove('hidden');
    }

    // Help modal
    function openHelp() { try { helpModal.showModal(); } catch(e){} }
    function closeHelp() { try { helpModal.close(); } catch(e){} }
    btnHelp.addEventListener('click', openHelp);
    btnCloseHelp.addEventListener('click', closeHelp);
    btnCloseHelpTop.addEventListener('click', closeHelp);
    elBtnHelpAuth.addEventListener('click', openHelp);

    // Auth
    function tryLogin() {
      const val = elPwd.value;
      if (val === HARDCODED_PASSWORD) {
        elAuth.classList.add('hidden');
        elApp.classList.remove('hidden');
        initApp();
      } else {
        setError(elAuthError, 'Falsches Passwort. Zugriff verweigert.');
      }
    }
    elBtnEnter.addEventListener('click', tryLogin);
    elPwd.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') tryLogin();
    });

    // Meta save: last open timestamp etc. (optional)
    function saveMeta() {
      const meta = { lastOpen: Date.now() };
      localStorage.setItem(LS_KEY_META, JSON.stringify(meta));
    }

    // Progress schema:
    // {
    //   learnedKeys: { [key]: true }, // key = section|de|en
    //   stats: { right: number, wrong: number }
    // }
    function loadProgress() {
      try {
        const raw = localStorage.getItem(LS_KEY_PROGRESS);
        if (!raw) return { learnedKeys: {}, stats: { right: 0, wrong: 0 } };
        const data = JSON.parse(raw);
        if (!data.learnedKeys || !data.stats) throw new Error('Ungültiges Fortschrittsformat');
        return data;
      } catch (e) {
        setError(elGlobalError, 'Fortschritt konnte nicht geladen werden. Grund: ' + e.message);
        return { learnedKeys: {}, stats: { right: 0, wrong: 0 } };
      }
    }
    function saveProgress(progress) {
      try {
        localStorage.setItem(LS_KEY_PROGRESS, JSON.stringify(progress));
      } catch (e) {
        setError(elGlobalError, 'Fortschritt konnte nicht gespeichert werden: ' + e.message);
      }
    }
    function makeKey(item) {
      return `${item.section}|||${item.de}|||${item.en}`;
    }

    function resetUIForTrain() {
      showingFeedback = false;
      elFeedback.classList.add('hidden');
      elAnswer.disabled = false;
      elBtnSkip.classList.remove('hidden');
      elBtnCheck.textContent = 'Überprüfen';
      elAnswer.value = '';
      elAnswer.focus({ preventScroll: true });
      setError(elQaError, null);
    }

    // Load vocabulary.json by fetch
    async function autoLoadVocabulary() {
      setError(elGlobalError, null);
      elLoadStatus.textContent = 'Lade vocabulary.json…';
      try {
        const res = await fetch('vocabulary.json', { cache: 'no-store' });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const json = await res.json();
        if (!Array.isArray(json)) throw new Error('Datei ist kein Array');
        validateVocabularyArray(json);
        vocabularyData = json;
        elLoadStatus.textContent = 'Vokabeln geladen.';
        setupSectionsAndQueues();
        showSections();
      } catch (e) {
        elLoadStatus.textContent = 'Laden fehlgeschlagen.';
        setError(elGlobalError, 'Konnte vocabulary.json nicht laden. Du kannst eine Datei manuell importieren. Details: ' + e.message);
      }
    }

    function validateVocabularyArray(arr) {
      const required = ['de','en','section','example'];
      const invalid = arr.find((x,i) => !required.every(k => typeof x[k] === 'string' && x[k].length >= 1));
      if (invalid) throw new Error('Ungültiges Vokabelformat: Felder de,en,section,example als nicht-leere Strings erforderlich.');
    }

    function setupSectionsAndQueues() {
      const progress = loadProgress();
      sections = Array.from(new Set(vocabularyData.map(v => v.section))).sort((a,b) => a.localeCompare(b));
      queues = {};
      sections.forEach(sec => {
        const items = vocabularyData.filter(v => v.section === sec);
        const openItems = items.filter(v => !progress.learnedKeys[makeKey(v)]);
        queues[sec] = openItems.map(v => ({ ...v, cooldown: 0 }));
      });

      // >>> NEU: "Alle Vokabeln" Section hinzufügen
      const allItems = vocabularyData.filter(v => !progress.learnedKeys[makeKey(v)]);
      if (allItems.length > 0) {
        sections.unshift("Alle Vokabeln"); // ganz vorne einfügen
        queues["Alle Vokabeln"] = allItems.map(v => ({ ...v, cooldown: 0 }));
      }

      currentSection = null;
      currentItem = null;
      sessionStats = { right: 0, wrong: 0 };
    }


    function showSections() {
      elLoaderCard.classList.add('hidden');
      elTrainerCard.classList.add('hidden');
      elSectionsCard.classList.remove('hidden');
      elSections.innerHTML = '';
      if (sections.length === 0) {
        elSections.innerHTML = '<div class="hint">Keine Sections gefunden. Bitte Vokabeldatei importieren.</div>';
        return;
      }
      const progress = loadProgress();
      sections.forEach(sec => {
        const total = vocabularyData.filter(v => v.section === sec).length;
        const open = queues[sec]?.length ?? 0;
        const done = total - open;
        const item = document.createElement('div');
        item.className = 'section-item';
        item.innerHTML = `
          <div>
            <div style="font-weight:700;">${escapeHtml(sec)}</div>
            <div class="hint">${open} offen • ${done}/${total} gelernt</div>
          </div>
          <div class="toolbar">
            <button class="btn ${open===0?'success':'primary'} small" data-sec="${escapeAttr(sec)}">
              ${open===0?'Erledigt':'Starten'}
            </button>
          </div>
        `;
        const btn = item.querySelector('button');
        btn.addEventListener('click', () => startSection(sec));
        elSections.appendChild(item);
      });
    }

    function startSection(sec) {
      currentSection = sec;
      elSectionsCard.classList.add('hidden');
      elTrainerCard.classList.remove('hidden');
      elStatusSection.textContent = sec;
      updateStatus();
      if ((queues[sec] ?? []).length === 0) {
        setError(elQaError, 'Diese Section ist bereits erledigt.');
        disableQAWhileDone();
        return;
      }
      nextQuestion();
    }

    function disableQAWhileDone() {
      elQuestion.textContent = 'Keine offenen Vokabeln.';
      elAnswer.value = '';
      elAnswer.disabled = true;
      elBtnSkip.classList.add('hidden');
      elBtnCheck.textContent = 'Weiter!';
      elBtnCheck.onclick = () => {
        elBtnCheck.onclick = onCheckClicked;
        showSections();
      };
    }

    function updateStatus() {
      const open = queues[currentSection]?.length ?? 0;
      elStatusOpen.textContent = open;
      elStatusRight.textContent = sessionStats.right;
      elStatusWrong.textContent = sessionStats.wrong;
    }

    function pickRandomItem(sec) {
      const q = queues[sec];
      if (!q || q.length === 0) return null;
      // Prefer items without cooldown; if none, decrement and allow all
      let pool = q.filter(it => it.cooldown <= 0);
      if (pool.length === 0) {
        q.forEach(it => { if (it.cooldown > 0) it.cooldown -= 1; });
        pool = q; // after decrement, allow all
      }
      const idx = Math.floor(Math.random() * pool.length);
      return pool[idx];
    }

    function nextQuestion() {
      resetUIForTrain();
      currentItem = pickRandomItem(currentSection);
      if (!currentItem) { // section done
        updateStatus();
        disableQAWhileDone();
        return;
      }
      elQuestion.textContent = currentItem.de;
    }

    function onCheckClicked() {
      setError(elQaError, null);
      if (showingFeedback) {
        // Continue to next after feedback
        elBtnCheck.textContent = 'Überprüfen';
        elBtnSkip.classList.remove('hidden');
        elFeedback.classList.add('hidden');
        elAnswer.disabled = false;
        showingFeedback = false;
        nextQuestion();
        return;
      }

      const val = elAnswer.value;
      if (!currentItem) { setError(elQaError, 'Keine aktuelle Frage.'); return; }
      if (!val || !val.trim()) { setError(elQaError, 'Bitte eine Antwort eingeben.'); elAnswer.focus(); return; }

      const correct = val === currentItem.en; // case-sensitive
      if (correct) {
        markLearned(currentItem);
        // Remove from queue of section
        const q = queues[currentSection];
        const idx = q.findIndex(x => makeKey(x) === makeKey(currentItem));
        if (idx >= 0) q.splice(idx, 1);
        sessionStats.right += 1;
        saveStats();
        updateStatus();
        nextQuestion();
      } else {
        sessionStats.wrong += 1;
        saveStats();
        // Show feedback: reveal solution and example; disable input; change buttons
        showFeedbackAndDefer(currentItem);
        // Move item back with cooldown
        deferItem(currentItem);
        updateStatus();
      }
    }

    function onSkipClicked() {
      if (!currentItem) return;
      // Treat as wrong answer for feedback & defer, but do not mark learned
      sessionStats.wrong += 1;
      saveStats();
      showFeedbackAndDefer(currentItem);
      deferItem(currentItem);
      updateStatus();
    }

    function showFeedbackAndDefer(item) {
      elSolution.textContent = item.en;
      elExample.textContent = item.example.replace('___', item.en);
      elFeedback.classList.remove('hidden');
      elAnswer.disabled = true;
      elBtnSkip.classList.add('hidden');
      elBtnCheck.textContent = 'Weiter!';
      showingFeedback = true;
    }

    function deferItem(item) {
      // Increase cooldown to avoid immediate repetition; ensure exists in queue
      const q = queues[currentSection];
      const key = makeKey(item);
      let found = q.find(x => makeKey(x) === key);
      if (!found) {
        // if somehow removed, add back
        q.push({ ...item, cooldown: 2 });
      } else {
        found.cooldown = Math.max(found.cooldown, 2);
        // Move to end
        const idx = q.findIndex(x => makeKey(x) === key);
        if (idx >= 0) {
          q.splice(idx, 1);
          q.push(found);
        }
      }
    }

    function markLearned(item) {
      const progress = loadProgress();
      progress.learnedKeys[makeKey(item)] = true;
      saveProgress(progress);
    }

    function saveStats() {
      const progress = loadProgress();
      progress.stats.right += (sessionStats.right - (progress.stats._sessionRight || 0));
      progress.stats.wrong += (sessionStats.wrong - (progress.stats._sessionWrong || 0));
      // Track snapshot to avoid double-counting if saveStats called multiple times
      progress.stats._sessionRight = sessionStats.right;
      progress.stats._sessionWrong = sessionStats.wrong;
      saveProgress(progress);
    }

    // Export / Import progress
    elBtnExport.addEventListener('click', () => {
      try {
        const progress = loadProgress();
        // Remove internal snapshot fields
        const clean = {
          learnedKeys: progress.learnedKeys || {},
          stats: { right: progress.stats?.right || 0, wrong: progress.stats?.wrong || 0 }
        };
        const blob = new Blob([JSON.stringify(clean, null, 2)], { type: 'application/json' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'progress.json';
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
          URL.revokeObjectURL(a.href);
          a.remove();
        }, 0);
      } catch (e) {
        setError(elGlobalError, 'Export fehlgeschlagen: ' + e.message);
      }
    });

    elImportProgress.addEventListener('change', async (ev) => {
      const file = ev.target.files?.[0];
      if (!file) return;
      try {
        const text = await file.text();
        const data = JSON.parse(text);
        if (!data || typeof data !== 'object' || !data.learnedKeys || !data.stats) {
          throw new Error('Ungültiges progress.json Format.');
        }
        // Merge: imported overwrites duplicates, preserves others
        const local = loadProgress();
        const merged = {
          learnedKeys: { ...local.learnedKeys, ...data.learnedKeys },
          stats: {
            right: data.stats.right ?? local.stats.right ?? 0,
            wrong: data.stats.wrong ?? local.stats.wrong ?? 0
          }
        };
        saveProgress(merged);
        // Rebuild queues to reflect merged progress
        setupSectionsAndQueues();
        // Keep current section view consistent
        showSections();
        setError(elGlobalError, null);
        alert('Import erfolgreich. Fortschritt aktualisiert.');
      } catch (e) {
        setError(elGlobalError, 'Import fehlgeschlagen: ' + e.message);
      } finally {
        ev.target.value = '';
      }
    });

    // Import custom vocabulary (not persisted)
    elImportVocab.addEventListener('change', async (ev) => {
      const file = ev.target.files?.[0];
      if (!file) return;
      try {
        const text = await file.text();
        const data = JSON.parse(text);
        validateVocabularyArray(data);
        vocabularyData = data;
        setupSectionsAndQueues();
        showSections();
        setError(elGlobalError, null);
        elLoadStatus.textContent = 'Eigene Vokabeln geladen.';
      } catch (e) {
        setError(elGlobalError, 'Vokabel-Import fehlgeschlagen: ' + e.message);
      } finally {
        ev.target.value = '';
      }
    });

    elBtnReloadVocab.addEventListener('click', autoLoadVocabulary);

    elBtnBackToSections.addEventListener('click', showSections);

    elBtnCheck.addEventListener('click', onCheckClicked);
    elBtnSkip.addEventListener('click', onSkipClicked);

    // Accessibility: Enter confirms
    elAnswer.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        elBtnCheck.click();
      }
    });

    // Escape HTML helpers
    function escapeHtml(str) {
      return String(str)
        .replaceAll('&','&amp;')
        .replaceAll('<','&lt;')
        .replaceAll('>','&gt;');
    }
    function escapeAttr(str) {
      return escapeHtml(str).replaceAll('"','&quot;');
    }

    function initApp() {
      saveMeta();
      autoLoadVocabulary().then(() => {
        // Focus management
        setTimeout(() => {
          if (!elTrainerCard.classList.contains('hidden')) {
            elAnswer.focus({ preventScroll: true });
          }
        }, 100);
      });
    }

    // Initial focus on password
    window.addEventListener('load', () => {
      try { elPwd.focus({ preventScroll: true }); } catch(e){}
    });
  </script>
</body>
</html>